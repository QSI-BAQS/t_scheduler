from __future__ import annotations
from abc import ABC
from enum import Enum
from typing import Any, List

from .patch import BufferPatch, Patch, PatchType
from .transaction import BaseTransaction, Transaction
from .constants import MEASURE_AND_CORR_DELAY, MOVE_T_NONLOCAL_DELAY


class GateType(Enum):
    """
    Types of gates supported.

    IMPLEMENTATION_DEFINED is generated by the compiler
    """

    LOCAL_GATE = 1
    ANCILLA = 2
    T_STATE = 3
    IMPLEMENTATION_DEFINED = 4


class BaseGate(ABC):
    """
    Base class for gates
    """

    targ: int
    targ_orig: int
    timer: int = 0
    duration: int = 0
    gate_type: GateType
    transaction: None | BaseTransaction

    pre: List[BaseGate]
    post: List[BaseGate]
    weight: float = 1
    schedule_weight: float = 0
    flag: Any = None

    def __init__(self):
        self.pre = []
        self.post = []

    def available(self):
        raise NotImplementedError()

    def tick(self):
        """
        Default impl: single stage gate.
        """
        self.timer += 1

    def completed(self) -> bool:
        """
        Returns if gate has completed, and is ready to be retired.
        """
        return self.timer >= self.duration

    def activate(self, *args, **kwargs):
        """
        Start the gate. Generic impl.
        """
        raise NotImplementedError()

    def cleanup(self, scheduler):
        """
        Release held resources. No-op if not overridden.
        """
        pass

    def next(self, scheduler):
        """
        Schedule dependent gates. No-op if not overridden.
        """
        pass


class Gate(BaseGate):
    def available(self):
        """
        Basic gate is always available
        """
        return True

    def activate(self, *args, **kwargs):
        # TODO impl ancilla/single qubit gates
        return super().activate(*args, **kwargs)


class T_Gate(BaseGate):
    targ: int
    targ_orig: int
    timer: int = 0
    duration: int = 0

    pre: List[BaseGate]
    post: List[BaseGate]
    weight: float = 1
    schedule_weight: float = 0

    def __init__(
        self,
        targ: int,
        move_duration: int = MOVE_T_NONLOCAL_DELAY,
        corr_duration: int = MEASURE_AND_CORR_DELAY,
        targ_orig=None,
    ):
        """
            Note: targ_orig is only used for repr().
        """
        if targ_orig is None:
            self.targ_orig = targ
        else:
            self.targ_orig = targ_orig

        self.targ: int = targ
        self.gate_type: GateType = GateType.T_STATE
        self.duration = move_duration
        self.correction_duration = corr_duration
        self.state = "JOINT"

        super().__init__()

    def available(self) -> bool:
        return all(g.completed() for g in self.pre)

    def activate(self, transaction: BaseTransaction):
        '''
        Activate this gate with the provided transaction
        '''
        transaction.activate()
        transaction.lock_move(self)
        self.transaction = transaction  # type: ignore

    def cleanup(self, scheduler):
        '''
        Update our state --> setting us to be incomplete if necessary
        '''
        if self.completed():
            self.transaction.unlock()  # type: ignore
            if self.state == "JOINT":
                self.timer = 0
                self.state = "CORRECTION"
                self.duration = self.correction_duration
                self.transaction.lock_measure(self)  # type: ignore
            else:
                self.transaction.release(scheduler.time)  # type: ignore

    def __repr__(self) -> str:
        str_pre = ",".join([str(x.targ_orig) for x in self.pre])
        str_post = ",".join([str(x.targ_orig) for x in self.post])
        return f"{str_pre}->T{self.targ_orig}({self.targ})->{str_post}"


class MoveGate(BaseGate):
    targ: str
    timer: int = 0
    duration: int

    move_target: None | Patch

    def __init__(self, move_duration: int = MOVE_T_NONLOCAL_DELAY):
        self.targ = "%"  # type: ignore
        self.gate_type: GateType = GateType.IMPLEMENTATION_DEFINED
        self.duration = move_duration
        self.move_target = None
        super().__init__()

    def available(self):
        return True

    def activate(self, transaction: BaseTransaction, move_target: BufferPatch):
        '''
        Activate this gate with the provided transaction. 

        Also tracks our move_target to be updated later
        '''
        transaction.activate()
        transaction.lock_move(self)
        self.transaction = transaction  # type: ignore
        self.move_target = move_target

    def cleanup(self, scheduler):
        '''
        Update internally our move target to be a T
        '''
        if self.completed():
            self.transaction.unlock()  # type: ignore
            self.transaction.release(scheduler.time)  # type: ignore
            self.move_target.store()  # type: ignore

    def next(self, scheduler):
        pass


class RotateGate(BaseGate):
    targ: int
    timer: int = 0
    duration: int = 0

    pre: List[BaseGate]
    post: List[BaseGate]
    weight: float = 1
    schedule_weight: float = 0

    transaction: BaseTransaction | None
    def __init__(
        self,
        t_patch: Patch,
        rotate_ancilla: Patch,
        reg_patch: Patch,
        rotate_for: T_Gate,
        duration: int,
    ):
        '''
            rotate_for is our gate that needed the rotation
        '''
        super().__init__()

        self.t_patch = t_patch
        self.t_patch.register_rotation(self)

        self.post.append(rotate_for)
        self.targ = rotate_for.targ
        self.duration = duration

        self.weight = rotate_for.weight
        self.schedule_weight = rotate_for.schedule_weight

        self.lock = None
        self.completed_at = None

        self.transaction = Transaction( 
            [t_patch, rotate_ancilla, reg_patch], []
        )

    def activate(self):
        self.transaction.activate() # type: ignore
        self.transaction.lock_move(self) # type: ignore

    def cleanup(self, scheduler):
        if self.completed():
            self.transaction.unlock() # type: ignore
            self.completed_at = scheduler.time
            # TODO add method for getting time

    def next(self, scheduler):
        '''
        Update orientation of the patch
        '''
        if self.completed():
            self.t_patch.orientation = self.t_patch.orientation.inverse()
